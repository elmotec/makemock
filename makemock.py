#!/usr/bin/env python
# encoding: utf-8

"""A regex based mock generator from .h header files."""

import re
import logging
import collections
import textwrap
import string

import click

__version__ = "0.5"  # UPDATE setup.py when changing version.
__author__ = "elmotec"
__license__ = "MIT"


log = logging.getLogger(__name__)
MockMethod = collections.namedtuple("MockMetod", "ret_type name parameters qualifiers")


def generate_mock_method(method):
    """Generate MOCK_METHOD google macro."""
    return (
        f"MOCK_METHOD({method.ret_type}, {method.name}, "
        f"{method.parameters}, ({method.qualifiers}));"
    )


def generate_default_delegation(method):
    """Generate ON_CALL default delegation statement."""
    arg_names, arg_type_and_names = [], []
    for index, arg in enumerate(method.parameters.replace("(", "").replace(")", "").split(",")):
        m = re.match(r"^\s*(?P<arg_type>(?:const\s+)?[:\w]+(?:\s*[\*\&])?)\s*(?P<arg>\w+)?\s*$", arg)
        if not m:
            continue
        arg_name = f"p{index}"
        arg_is_matched = m.lastindex >= 2
        if arg_is_matched:
            arg_name = m.group("arg")
        arg_type_and_name = f"{m.group('arg_type')} {arg_name}"
        arg_type_and_names.append(arg_type_and_name)
        arg_names.append(arg_name)
    return f"ON_CALL({method.name}({', '.join(arg_type_and_names)})).WillByDefault(Return(real->{method.name}({', '.join(arg_names)}));"


def get_header_template():
    """Generate default template."""
    return textwrap.dedent(
        """
    #ifndef %(guard)s
    #define %(guard)s

    /*
     * file generated by makemock: %(mock_file_hpp)s
     * 
     */

    #include <gmock/gmock.h>
    #include "${dir}/${file}"

    ${namespaces_begin}

    ${template}class ${interface}Mock : public ${template_interface}
    {
    public:
    ${mock_methods}
    };

    ${namespaces_end}

    #endif // ${guard}
    """
    )


def get_basic_template():
    """Generate default template."""
    return textwrap.dedent(
        """
    ${mock_methods}

    ${delegate_to}

    """
    )


get_default_template = get_basic_template


class MockMaker:
    """Makes a mock file from a C++ header file."""

    method_decl_re = re.compile(
        r"^\s*(?P<virtual>virtual)?\s*(?P<ret_type>[\w:<>,\s&*]+)\s+(?P<name>\w+)(?P<params>\([^\)]*\))(?P<qualifiers>(?:\s*\w+)*)(\s*=.*)?"
    )

    def __init__(self, indent=None):
        """Initialize MockMaker."""
        pass

    def parse_method(self, match):
        """Process match from the regular expression."""
        ret_type = match.group("ret_type")
        name = match.group("name")
        params = match.group("params")
        quals = match.group("qualifiers").split()
        if "override" not in quals and not match.group("virtual"):
            return None
        if "override" not in quals:
            quals.append("override")
        params = re.sub(r"\s+", " ", params)
        return MockMethod(ret_type, name, params, ", ".join(quals))

    def find_methods_to_mock(self, input):
        """Makes the mock."""
        content = input.read()
        methods = []
        for statement in content.split(";"):
            match = self.method_decl_re.match(statement)
            if not match:
                continue
            method = self.parse_method(match)
            if not method:
                continue
            methods.append(method)
        return methods

    def make_mock(self, input, output, template=None):
        """Makes the mock.

        Args:
            input: input header or snippet of code.
            output: output mock .cpp.
            template: template to use for output.

        """
        methods = self.find_methods_to_mock(input)
        mock_methods = "\n".join(generate_mock_method(method) for method in methods)
        interface = ""
        guard = "INC_" + interface.upper() + "_H"
        namespaces, namespaces_begin, namespaces_end = "", "", ""
        delegate_to = (
            "void MockProdClass::DelegateTo(ProdClass * real)\n{\n"
            + "\n".join([generate_default_delegation(method) for method in methods])
            + "\n}"
        )
        if namespaces:
            namespaces_begin = "namespace " + namespaces + "\n{"
            namespaces_end = "}\n"
        if template is None:
            generated = mock_methods
        else:
            mappings = {
                "dir": "",
                "file": "",
                "template": "",
                "mock_methods": mock_methods,
                "template_interface": interface,
                "interface": interface,
                "guard": guard,
                "delegate_to": delegate_to,
                "namespaces_begin": namespaces_begin,
                "namespaces_end": namespaces_end,
            }
            generated = string.Template(template).substitute(mappings)
        output.write(generated)

    def __call__(self, *args, **kwargs):
        return self.make_mock(*args, **kwargs)


@click.command()
@click.argument("input", type=click.File("r"))
@click.option("-o", "--outuput", type=click.File("w"), default="-", help="output file")
def main(input, output):
    """Process a C++ header file and generate a mock class based on it.

    This tool is regex based and does not handle all c++, notably:
    - no support for operators.
    - (TBD)

    """
    mockmaker = MockMaker()
    mockmaker.make_mock(input, output)
    return 0


if __name__ == "__main__":
    main()
